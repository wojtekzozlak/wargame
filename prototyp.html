<html>
  <head>
  </head>
  <body>
    Ship A
<!--    <textarea id="logic1" style="width: 400px; height: 200px;">env.targetAngle = (env.currentAngle + 1) % 360;
env.targetSpeed = 1;</textarea>
    Ship B
    <textarea id="logic2" style="width: 400px; height: 200px;">env.targetAngle = (env.currentAngle + 1) % 360;
env.targetSpeed = 2;
env.shoot = true;</textarea> -->
    <textarea id="logic1" style="width: 400px; height: 200px;">env.targetAngle = 180;
env.targetSpeed = 100;</textarea>
    Ship B
    <textarea id="logic2" style="width: 400px; height: 200px;">
env.targetAngle = env.targetAngle + env.relativeAngles[0];
env.targetSpeed = 150;
if (env.distances[0] < 150) {
  env.shoot = true;
}</textarea>
    <input type="button" value="run" onclick="run();"/>
    <canvas id="game" width="1024" height="768"></canvas>
   	<script>

var TIME_LIMIT = 10000;
var FPS = 50;
var DELTA_PER_FRAME = 1000 / FPS;

var ObjectType = {
  UNKNOWN: 'UNKNOWN',
  SHIP: 'SHIP',
  ROCKET: 'ROCKET'
};

var extendDict = function(a, b) {
  for (var attr in b) {
  	a[attr] = b[attr];
  }
}

var objectKeys = function(obj) {
  var result = [];
  for (var k in obj) {
  	result.push(k);
  }
  return result;
};

var abstractMethod = function() {
  throw 'Not Implemented!';
};

var rotateVector = function(x, y, angle) {
  var rad_angle = angle * Math.PI / 180;
  var dx = x * Math.cos(rad_angle) - y * Math.sin(rad_angle);
  var dy = x * Math.sin(rad_angle) + y * Math.cos(rad_angle);
  return {x: dx, y: dy};
}

var SimulationObject = function(positionX, positionY, angle, speed, faction) {
  this._positionX = positionX;
  this._positionY = positionY;
  this._angle = angle;
  this._speed = speed;
  this._faction = faction;
  this._messages = [];
};
SimulationObject.prototype.reconfigure = abstractMethod;
SimulationObject.prototype.getProperties = abstractMethod;
SimulationObject.prototype._typeId = ObjectType.UNKNOWN;
SimulationObject.prototype._emitMessage = function(msg) {
  this._messages.push(msg);
};
SimulationObject.prototype.collectMessages = function() {
  var tmp = this._messages;
  this._messages = [];
  return tmp;
};
SimulationObject.prototype.computeStep = function(time_delta) {
  var movement = rotateVector(0, this._speed * time_delta / 1000, this._angle);
  this._positionX += movement.x;
  this._positionY += movement.y;
};
SimulationObject.prototype.getProperties = function() {
  return {
  	x: this._positionX,
  	y: this._positionY,
  	angle: this._angle,
  	typeId: this._typeId,
  	faction: this._faction
  };
};
SimulationObject.prototype.distance = function(other) {
  var dx = this._positionX - other._positionX;
  var dy = this._positionY - other._positionY;
  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
};


var Rocket = function(positionX, positionY, angle) {
  SimulationObject.call(this, positionX, positionY, angle, /*speed=*/400, /*faction=*/null);
};
Rocket.prototype = Object.create(SimulationObject.prototype);
Rocket.prototype.reconfigure = function() {}
Rocket.prototype._typeId = ObjectType.ROCKET;


var Ship = function(positionX, positionY, angle, logic, faction) {
  SimulationObject.call(this, positionX, positionY, angle, /*speed=*/0, faction);
  this._logic = logic;
  this._modules = {};
};
Ship.prototype = Object.create(SimulationObject.prototype);
Ship.prototype._typeId = ObjectType.SHIP;
Ship.prototype.computeStep = function(time_delta) {
  for (var module_name in this._modules) {
  	this._modules[module_name].computeStep(time_delta);
  }
  SimulationObject.prototype.computeStep.call(this, time_delta);
};
Ship.prototype._getInnerProperties = function() {
  var properties = {};
  for (var module_name in this._modules) {
    extendDict(properties, this._modules[module_name].getProperties());	
  }
  return properties;
};
Ship.prototype.registerModule = function(name, module) {
  this._modules[name] = module;
  module.wireShip(this)
};
Ship.prototype.reconfigure = function() {
  var env = this._getInnerProperties();

  eval(this._logic);
  for (var module_name in this._modules) {
  	this._modules[module_name].loadProperties(env);
  }
};


var ShipModule = function() {
  this._ship = null;
};
ShipModule.prototype.wireShip = function(ship) {
  this._ship = ship;
};
ShipModule.prototype.getProperties = abstractMethod;
ShipModule.prototype.loadProperties = abstractMethod;
ShipModule.prototype.computeStep = function(unused_time_delta) {};


var EngineModule = function() {
  ShipModule.call(this);
  this._maneuverability = 90;  // 90 deg per second.
  this._acceleration = 25;  // 25 units per second.
  this._targetAngle = 0;
  this._targetSpeed = 0;
};
EngineModule.prototype = Object.create(ShipModule.prototype);
EngineModule.prototype.wireShip = function(ship) {
  ShipModule.prototype.wireShip.call(this, ship);
  this._targetAngle = ship._angle;
  this._targetSpeed = ship._speed;
};
EngineModule.prototype.getProperties = function() {
  return {
  	currentSpeed: this._ship_speed,
  	targetSpeed: this._targetSpeed,
  	currentAngle: this._ship._angle,
  	targetAngle: this._targetAngle
  };
};
EngineModule.prototype.loadProperties = function(env) {
  /* Assert valid input. */
  this._targetSpeed = env['targetSpeed'];
  this._targetAngle = env['targetAngle'] % 360;
};
EngineModule.prototype.computeStep = function(time_delta) {
  this._adjustAngle(time_delta);
};
EngineModule.prototype._adjustAngle = function(time_delta) {
  var desired_angle_change = this._targetAngle - this._ship._angle;
  this._ship._angle += this._throttledChange(time_delta, this._maneuverability, desired_angle_change);
  var desired_speed_change = this._targetSpeed - this._ship._speed;
  this._ship._speed += this._throttledChange(time_delta, this._acceleration, desired_speed_change);
};
EngineModule.prototype._throttledChange = function(time_delta, change_speed, desired_change) {
  var max_change = change_speed * time_delta / 1000;
  var throttled_change = Math.min(desired_change, max_change);
  throttled_change = Math.max(throttled_change, -max_change);
  return throttled_change;
};


var WeaponModule = function(simulation) {
  ShipModule.call(this);
  this._simulation = simulation;
  this._time_since_last_shot = Number.MAX_SAFE_INTEGER;
  this._reload_time = 1000;
};
WeaponModule.prototype = Object.create(ShipModule.prototype);
WeaponModule.prototype._ammoAvailable = function() {
  return this._time_since_last_shot >= this._reload_time;
};
WeaponModule.prototype.getProperties = function() {
  return {
    ammoAvailable: this._ammoAvailable()
  };
};
WeaponModule.prototype.loadProperties = function(env) {
  if (env.shoot && this._ammoAvailable()) {
  	this._time_since_last_shot = 0;
  	var ship_properties = this._ship.getProperties();
  	var offset = rotateVector(0, 10, ship_properties.angle);
  	this._simulation.addObject(new Rocket(ship_properties.x + offset.x,
  		                                  ship_properties.y + offset.y,
  		                                  ship_properties.angle));
  	this._ship._emitMessage("Shoot!");
  }
};
WeaponModule.prototype.computeStep = function(time_delta) {
  this._time_since_last_shot += time_delta;
};


var SensorModule = function(simulation) {
   ShipModule.call(this);
   this._simulation = simulation;
};
SensorModule.prototype = Object.create(ShipModule.prototype);
SensorModule.prototype.getProperties = function() {
  var enemies = this._getEnemyShips();
  var relative_angles = [];
  var distances = [];
  for (var i = 0; i < enemies.length; ++i) {
  	relative_angles.push(this._relativeAngle(enemies[i]));
  	distances.push(this._ship.distance(enemies[i]));
  }
  return {
  	relativeAngles: relative_angles,
  	distances: distances
  }
};
SensorModule.prototype.loadProperties = function(unused_env) {};
SensorModule.prototype._relativeAngle = function(ship) {
  var a_properties = this._ship.getProperties();
  var b_properties = ship.getProperties();
  var dx = b_properties.x - a_properties.x;
  var dy = b_properties.y - a_properties.y;
  var angle = (360 + Math.atan2(-dx, dy) * 180 / Math.PI) % 360;
  return angle - a_properties.angle;
};
SensorModule.prototype._getEnemyShips = function() {
  var enemies = [];
  for (var i = 0; i < this._simulation._objects.length; ++i) {
  	var object = this._simulation._objects[i];
  	var object_properties = object.getProperties();
  	if (object_properties.typeId == ObjectType.SHIP &&
  		object_properties.faction != null &&
  		object_properties.faction != this._ship._faction) {
  	  enemies.push(object);
  	}
  }
  return enemies;
}


var Simulation = function() {
  this._objects = [];
};

Simulation.prototype.addObject = function(object) {
  this._objects.push(object);
};

Simulation.prototype.computeStep = function(time_delta) {
  for (var i = 0; i < this._objects.length; ++i) {
  	this._objects[i].reconfigure();
  	this._objects[i].computeStep(time_delta);
  }
  this._detectCollisions();
};

Simulation.prototype._detectCollisions = function() {
  // Simple O(n^2) algorithm.
  var destroyed = {};
  for (var i = 0; i < this._objects.length; ++i) {
  	for (var j = i + 1; j < this._objects.length; ++j) {
      // Replace intersection of hitboxes.
  	  var distance = this._objects[i].distance(this._objects[j]);
  	  if (distance < 5) {
  	  	destroyed[i] = true;
  	  	destroyed[j] = true;
  	  }
  	}
  }

  var remaining_objects = [];
  for (var i = 0; i < this._objects.length; ++i) {
  	if (!(i in destroyed)) {
  	  remaining_objects.push(this._objects[i]);
  	}
  }

  this._objects = remaining_objects;
};

Simulation.prototype._factionsAlive = function() {
  var factions_alive = {};
  for (var i = 0; i < this._objects.length; ++i) {
  	var obj_faction = this._objects[i].getProperties().faction;
  	if (obj_faction != null) {
      factions_alive[obj_faction] = true;
  	}
  }
  return objectKeys(factions_alive);
};

Simulation.prototype.finished = function() {
  return this._factionsAlive().length <= 1;
};

Simulation.prototype.dumpFrame = function() {
  var frame = [];
  for (var i = 0; i < this._objects.length; ++i) {
  	var object = this._objects[i];
  	var object_dump = object.getProperties();
  	object_dump.messages = object.collectMessages();
  	frame.push(object_dump);
  }
  return frame;
};

var Visualization = function(canvas) {
  this._canvas = canvas;
  this._renderers = {};
};

Visualization.prototype.renderFrame = function(frame) {
  var ctx = this._canvas.getContext("2d");
  ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
  for (var i = 0; i < frame.length; ++i) {
  	var object = frame[i];
  	ctx.save();
    ctx.translate(400, 400);
    ctx.translate(object.x, object.y);
    ctx.rotate(object.angle * Math.PI / 180);
    this._renderers[object.typeId](ctx);
    ctx.restore();

    for (var j = 0; j < object.messages.length; ++j) {
      console.log(object.messages[j]);
    }
  }
}

Visualization.prototype.registerRenderer = function(type_id, renderer) {
  this._renderers[type_id] = renderer;
}

var shipRenderer = function(ctx) {
  ctx.fillStyle = '#000000';
  ctx.beginPath();
  ctx.moveTo(0, 15);
  ctx.lineTo(10, -15);
  ctx.lineTo(-10, -15);
  ctx.closePath();
  ctx.fill();
}

var rocketRenderer = function(ctx) {
  ctx.fillRect(-2, -10, 4, 20);
}

var timer_id = null;
var run = function() {
  clearTimeout(timer_id);
  var sim = new Simulation();
  for (var i = 1; i <= 2; ++i) {
    var logic = document.getElementById("logic" + i).value;
    var ship = new Ship(200 * (i - 1), 50 * (i - 1), 180 * (i - 1), logic, "player" + i);
    ship.registerModule("engine", new EngineModule());
    ship.registerModule("weapons", new WeaponModule(sim));
    ship.registerModule("sensors", new SensorModule(sim));
    sim.addObject(ship);
  }

  var viz = new Visualization(document.getElementById("game"));
  viz.registerRenderer(ObjectType.SHIP, shipRenderer);
  viz.registerRenderer(ObjectType.ROCKET, rocketRenderer);

  var frames = [];
  for (var i = 0; !sim.finished() && i < TIME_LIMIT; i+=DELTA_PER_FRAME) {
    sim.computeStep(DELTA_PER_FRAME);
    frames.push(sim.dumpFrame());
  }

  var i = 0;
  timer_id = setInterval(function() {
    if (i == frames.length) {
  	  clearTimeout(timer_id);
  	  return;
  	}

  	viz.renderFrame(frames[i]);
  	++i;
  }, DELTA_PER_FRAME);
};


  	</script>
  </body>
</html>